#include <iostream>
#include <cfloat>
#include "../mp2p-fem1d/mp2p_fem1d.hpp"

int main()
{
    
    // variables
    double c1_a = 0.1;
    double j2_a = 0.002;
    double j1_b = 0.003;
    double c2_b = 0.4;
    double diff1 = 0.05;
    double diff2 = 0.006;
    double k = 0.07;

    // initialize mesh
    // this can be shared among variables that occupy the same domain
    MeshLine2 mesh_dom1("input/05_input/mesh_point.csv", "input/05_input/mesh_element.csv");  // mesh for domain 1

    // initialize boundary conditions
    // need one boundary condition for each variable
    BoundaryLine2 boundary_c1_dom1("input/05_input/boundary_flux_c1.csv", "input/05_input/boundary_value_c1.csv");
    boundary_c1_dom1.set_boundarycondition(0, "neumann", {-j1_b});  // negative for outward flux
    boundary_c1_dom1.set_boundarycondition(1, "dirichlet", {c1_a});
    BoundaryLine2 boundary_c2_dom1("input/05_input/boundary_flux_c2.csv", "input/05_input/boundary_value_c2.csv");
    boundary_c2_dom1.set_boundarycondition(2, "neumann", {-j2_a});  // negative for outward flux
    boundary_c2_dom1.set_boundarycondition(3, "dirichlet", {c2_b});

    // initialize integrals
    // this can be shared among variables that occupy the same domain
    IntegralLine2 integral_dom1(mesh_dom1);  // intergrals for domain 1

    // initialize variables
    // these are unknowns to be solved for
    VariableLine2 c1_dom1(mesh_dom1, 0.0);  // supplied an initial guess of 0 for c1 in domain 1
    VariableLine2 c2_dom1(mesh_dom1, 0.0);  // supplied an initial guess of 0 for c2 in domain 1

    // initialize scalars
    ScalarLine2 diff1_dom1(mesh_dom1, diff1);  // supplied a constant value for c1 in domain 1
    ScalarLine2 diff2_dom1(mesh_dom1, diff2);  // supplied a constant value for c2 in domain 1
    ScalarLine2 rxnrate1_dom1(mesh_dom1, 0.0);  // use a placeholder value
    ScalarLine2 rxnrate2_dom1(mesh_dom1, 0.0);  // use a placeholder value

    // set up two physics - one for each species

    // the physics for species 1 acts on domain 1, so group the mesh, etc. for domain 1
    MeshField mesh_fld1({&mesh_dom1});
    BoundaryField boundary_fld1({&boundary_c1_dom1});
    IntegralField integral_fld1({&integral_dom1});
    VariableField c1_fld1({&c1_dom1});
    ScalarField diff1_fld1({&diff1_dom1});
    ScalarField rxnrate1_fld1({&rxnrate1_dom1});
    
    // the physics for species 2 acts on domain 1, so group the mesh, etc. for domain 1
    MeshField mesh_fld2({&mesh_dom1});
    BoundaryField boundary_fld2({&boundary_c2_dom1});
    IntegralField integral_fld2({&integral_dom1});
    VariableField c2_fld2({&c2_dom1});
    ScalarField diff2_fld2({&diff2_dom1});
    ScalarField rxnrate2_fld2({&rxnrate2_dom1});

    // initialize physics
    // 0 = -div(-b * grad(u)) + c
    // value (to be solved for), u - c1 or c2
    // diffusion coefficient, b - diffusion coefficient
    // generation coefficient, c - rate of reaction
    PhysicsSteadyDiffusion diffusion1(mesh_fld1, boundary_fld1, integral_fld1, c1_fld1, diff1_fld1, rxnrate1_fld1);
    PhysicsSteadyDiffusion diffusion2(mesh_fld2, boundary_fld2, integral_fld2, c2_fld2, diff2_fld2, rxnrate2_fld2);

    // load physics into matrix equation
    // this will set up the system of equations to be solved for (Ax = b)
    MatrixEquationSteady matrixeq({&diffusion1, &diffusion2});

    // initialize for iteration
    int num_iter_max = 500;  // maximum number of iterations
    double l2_norm_tol = 1e-5;  // stop if L2 norm reaches this
    double l2_norm = DBL_MAX;

    // iterate to convergence
    for (int it = 0; it < num_iter_max; it++)
    {
        
        // iterate over domain ID (did) of points in domain
        // calculate rate of reaction
        for (int did = 0; did < mesh_dom1.num_point_domain; did++)
        {
            double rxn_rate = k * c1_dom1.point_value_vec[did] * c2_dom1.point_value_vec[did];
            rxnrate1_dom1.point_value_vec[did] = -rxn_rate; // consumed by reaction
            rxnrate2_dom1.point_value_vec[did] = +rxn_rate; // generated by reaction
        }

        // perform one iteration of the matrix equation
        Eigen::VectorXd x_last_iteration_vec = matrixeq.x_vec;  // store x in Ax = b
        matrixeq.iterate_solution();  // solve for x
        Eigen::VectorXd x_next_iteration_vec = matrixeq.x_vec;  // store new x
        matrixeq.store_solution();  // transfer values of x into variable objects

        // calculate L2 norm
        l2_norm = (x_next_iteration_vec - x_last_iteration_vec).norm();
        std::cout << "Iteration: " << it << ", L2 Norm: " << l2_norm << "\n";

        // stop if convergence is reached
        if (l2_norm < l2_norm_tol)
        {
            break;
        }

    }

    // output results
    c1_dom1.output_csv("output/05_output/c1_dom1.csv");
    c2_dom1.output_csv("output/05_output/c2_dom1.csv");

}
